use std::{
    io,
    net::{IpAddr, SocketAddr, SocketAddrV4},
    time::Duration,
};

use tokio::{
    net::{TcpListener, TcpStream, UdpSocket},
    time::sleep,
};

#[tokio::main]
async fn main() {
    // try_main(Config {
    //     tunnels: vec![
    //         Tunnel {
    //             listen: "127.0.0.1:5454".parse().unwrap(),
    //             forward: "127.0.0.1:6464".parse().unwrap(),
    //         },
    //         Tunnel {
    //             listen: "127.0.0.1:5455".parse().unwrap(),
    //             forward: "127.0.0.1:6465".parse().unwrap(),
    //         },
    //     ],
    // })
    // .await

    try_main2();

    loop {
        sleep(Duration::from_secs(10)).await;
    }
}

async fn try_main(config: Config) {
    for tunnel in config.tunnels {
        Listener::new(tunnel.listen, tunnel.forward).await.spawn();
    }

    loop {
        sleep(Duration::from_secs(10)).await;
    }
}

async fn try_main2() {
    let machine = Machine {
        hardware_address: [0x01, 0x02, 0x03, 0x04, 0x05, 0x06],
        address: "10.0.0.123".parse().unwrap(),
        broadcast: "10.0.0.255".parse().unwrap(),
    };

    let s = machine.connect(6666).await;
    println!("{s:#?}");
}

// Features:
//  * send WOL packets only as needed (use the "no route to host" error)
//  * configurable timeout to allow for the machine to wake up
//  * configurable broadcast address /machine

struct Machine {
    hardware_address: [u8; 6],
    address: IpAddr,
    broadcast: IpAddr,
}

impl Machine {
    async fn wake(&self) {
        let mut packet = Vec::with_capacity(6 + 6 * 16);
        packet.extend_from_slice(&[0xff; 6]);
        for _ in 0..16 {
            packet.extend_from_slice(&self.hardware_address);
        }

        let s = UdpSocket::bind("0.0.0.0:0").await.unwrap();

        s.send_to(&packet, SocketAddr::new(self.broadcast, 7))
            .await
            .unwrap();
    }

    async fn connect(&self, port: u16) -> TcpStream {
        let dst = SocketAddr::new(self.address, port);
        println!("{dst}");

        loop {
            let r = TcpStream::connect(dst).await;

            match r {
                Ok(s) => return s,
                Err(e) => {
                    panic!("{e:#?}")
                }
            }
        }
    }
}

struct Config {
    tunnels: Vec<Tunnel>,
}

struct Tunnel {
    listen: SocketAddr,
    forward: SocketAddr,
}

struct Listener {
    listener: TcpListener,
    forward: SocketAddr,
}

impl Listener {
    pub async fn new(bind: SocketAddr, forward: SocketAddr) -> Self {
        let listener = TcpListener::bind(bind)
            .await
            .expect("failed to bind listener");

        Self { listener, forward }
    }

    pub async fn run(mut self) -> ! {
        loop {
            let (mut outer, addr) = self.listener.accept().await.unwrap();
            eprintln!("connected: {addr}");

            eprintln!("spawning {addr}<->{}", self.forward);

            tokio::spawn(async move {
                let mut inner = TcpStream::connect(self.forward).await.unwrap();

                let r = tokio::io::copy_bidirectional(&mut outer, &mut inner).await;

                match r {
                    Ok(_) => {}
                    Err(e) => {
                        eprintln!("failed to forward connection: {e}")
                    }
                }
            });
        }
    }

    pub fn spawn(self) {
        tokio::spawn(async move { self.run().await });
    }
}
