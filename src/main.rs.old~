use std::{net::SocketAddr, time::Duration};

use tokio::{
    net::{TcpListener, TcpStream},
    time::sleep,
};

#[tokio::main]
async fn main() {
    try_main(Config {
        tunnels: vec![
            Tunnel {
                listen: "127.0.0.1:5454".parse().unwrap(),
                forward: "127.0.0.1:6464".parse().unwrap(),
            },
            Tunnel {
                listen: "127.0.0.1:5455".parse().unwrap(),
                forward: "127.0.0.1:6465".parse().unwrap(),
            },
        ],
    })
    .await
}

async fn try_main(config: Config) {
    for tunnel in config.tunnels {
        Listener::new(tunnel.listen, tunnel.forward).await.spawn();
    }

    loop {
        sleep(Duration::from_secs(10)).await;
    }
}

struct Config {
    tunnels: Vec<Tunnel>,
}

struct Tunnel {
    listen: SocketAddr,
    forward: SocketAddr,
}

struct Listener {
    listener: TcpListener,
    forward: SocketAddr,
}

impl Listener {
    pub async fn new(bind: SocketAddr, forward: SocketAddr) -> Self {
        let listener = TcpListener::bind(bind)
            .await
            .expect("failed to bind listener");

        Self { listener, forward }
    }

    pub async fn run(mut self) -> ! {
        loop {
            let (mut outer, addr) = self.listener.accept().await.unwrap();
            eprintln!("connected: {addr}");

            eprintln!("spawning {addr}<->{}", self.forward);

            tokio::spawn(async move {
                let mut inner = TcpStream::connect(self.forward).await.unwrap();

                let r = tokio::io::copy_bidirectional(&mut outer, &mut inner).await;

                match r {
                    Ok(_) => {}
                    Err(e) => {
                        eprintln!("failed to forward connection: {e}")
                    }
                }
            });
        }
    }

    pub fn spawn(self) {
        tokio::spawn(async move { self.run().await });
    }
}
